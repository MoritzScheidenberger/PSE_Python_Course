---
title: |
  ![](main_quarto_files/pse_logo.png){style="float: right; width: 100px;"}
  Writing a Story
subtitle: "Understanding the Impact of Uncertainty on Replacement Hiring"
author: "Moritz Scheidenberger"
date-modified: "today"
abstract: "In the labor market, transitions in and out of unemployment are driven by two wheels.
    One wheel is the classical cycle of job creation and job destruction. Firms create jobs for which they hire unemployed workers. Simulatenously, some already filled jobs are destroyed and the associated workers become unemployed.
    The second wheel is driven by churn. Some already employed workers are hired by ohter firms and leave behind an empty position which, subsequently, may be filled by another already employed worker who themselves leaves behind a position. So the churn wheel keeps turning until the empty position is filled by a previously unemployed worker.
    The conventional view is that models of the labor market model can abstract from the churn wheel when mainly interested in unemployment dynamics. Since job creation must equal job destruction, the number of UE transitions (unemployement to employment) is determined by the EU transitions (employment to unemployment). EE transitions (employment to employment) offset eachother and do not matter for unemploymend dynamics. Yet, disregarding replacement hiring dynamics risks missing essential labor market effects when economic shocks alter firms' quit replacement decisions through mechanisms beyond the usual business cycle impact.
    I provide novel evidence that uncertainty shocks directly impact firms' replacement hiring decisions. The reluctance to rehire under uncertainty arises because firms treat existing positions as valuable but sunk investments, leading to a wait-and-see approach."

format:
  html:
    theme:
      light: flatly  # Set light mode as default
      dark: darkly   # Fallback for dark mode
    css: main_quarto_files/costum_style.css
    fig-format: svg
    fig-dpi: 600
    code-fold: true
    toc: true
    toc-location: right
    toc-title: "Contents"
    toc-depth: 3
    smooth-scroll: true

title-block-style: "default"
title-block-banner: "#921539"
title-block-banner-color: "white"
mainfont: "Segoe UI"

number-sections: true

jupyter: quarto_env  # Use the Conda environment

# Turns out that one has to use knitr & R to run all the python code
# once the quarto document also contains R code

# This is what it takes to make things run
execute:
  eval: true
  freeze: auto
  fig-show: none  # Prevent automatic figure display

  # warning: false  # This suppresses all warnings globally
# engine: knitr



---

```{python}
#| label: legacy_code
#| echo: false
#| include: false

# This would have to be an R block to work
# But then, everything runs in R, even python code

# knitr::opts_chunk$set(echo = TRUE)

# library(reticulate)

# Force Reticulate to use "quarto_env"
# use_condaenv("quarto_env", required = TRUE)

# To check the current Python version:
# reticulate::py_config()

```


# Motivation
From the literature that followed the Great Recession, the consensus has emerged that such uncertainty shocks have substantial negative effects on investment and unemployment.
While the impact on investment can be rationalized through the standard real options channel, models of the labor market have struggled to replicate the sizable rise in unemployment observed in the data.
This project is the start of an investigation into whether accounting for changes in firms' replacement hiring decisions can overcome this discrepancy between theory and data.

## The Role of Replacement Hiring
While job creation and job destruction have been the focal point of attention of labor economists for decades, the role of replacement hiring has only recently received attention.
Replacement hiring is the process by which firms fill positions left behind by workers who quit or are laid off.
Mechanically connected to on-the-job transitions (that is, workers moving from one employer to another), replacement hiring is a crucial part of the job ladder.
The job ladder is the sequence of jobs that workers climb over their career. When a worker climbs a rung on the job ladder by transitioning to another employer, they leave behind a viable position that can be filled by another worker.
This empty positions constitutes the opportunity for another worker to themselves climb a rung on the job ladder and so on.
In this way, the job ladder is a dynamic process that is constantly turning as workers transition between employers.
The job ladder itself plays a crucial role for e.g. productivity growth and wage growth, though the details of this are beyond the scope of this project.

Before turning to the measurement of replacement hiring, here are some key points to keep in mind:

- Half of all hires are replacement hires. This is synonymous to saying that half of all hires are EE transitions.
- The size of EE flows is about equal the size of EU flows. This highlights the importance of EE transitions for the labor market.


## How to Measure Replacement Hiring
While there exists data on the number of replacement hires, firms' actual decisions to replacement hire cannot be inferred directly.
Since the number of replacement hires is capped by the number of workers quitting their positions, any change in worker quits mechanically reduces the number of replacement hires.
In other words, an observed fall in replacement hiring could be both the consequence of firms' reluctance to rehire or simply a fall in the number of quits.
Thus, to estimate the number of quits that remain unreplaced, one has to control for any movement in replacement hiring that is driven by a change in the number of workers quitting their jobs and leaving behind a viable position.

One may be tempted to think that simply using the number of quits as a proxy for the number of empty positions left behind by workers leaving their firm. However, this approach is flawed for two reasons.
Firstly, recent work by Carillo-Tuleda et al. (2021) shows that in non-recession years about 39% of layoffs also leave behind a viable position. The motive of such layoffs being worker performance (termed bad match quality in the literature) rather than job destruction. Still, simply adding a constant share of layoffs to the number of quits to get at the number of replaceable positions may be problematic if the share of replaceable layoffs varies structurally over the cycle. At the onset of recessions, layoffs spike while quits fall. How does the share of match-quality motivated layoffs change in recessions? Does it rise because worker performance matters more during downturns? Or does it fall because the motive of job destruction becomes more prevalent?
Secondly, labor markets are not just driven by flows. Job openings do not vanish after the last day of a quarter. Instead, there exists a stock of job openings on the labor market. At any given moment, new jobs are posted and added to the stock, existing jobs openings are filled by searching workers and some job openings expire without finding a matching worker. Therefore, the short-term response of labor market variables is not only driven by the flows but also by how such changes in the flows affect the stocks.

We are left with two options:

1. Construct a series of viable positions left behind by quits and layoffs, assuming that the share of layoffs that leave behind a viable position is constant over the cycle. In an extension, one could try to come up with a proxy for the share of replaceable layoffs for which data exists.

2. Infer the number of viable positions left behind from data on job-to-job transitions. **This is the approach I go for in this project.** The argument goes as follows:

In models of the labor market, flows can be categorized into two "wheels". The first wheel is the classical cycle of job creation and job destruction. The second wheel is that of replacement hiring. EE transitions leave behind viable positions that are filled by other EE transitions. When looked at through this lense, the two wheels can be regarded as independent from eachother. Job creation and job destruction determine unemployment-to-employment (UE) and employment-to-unemployment (EU) flows respectively. EE tranistions offset eachother and do not matter for unemployment dynamics.
Importantly, the two identities that these two wheels represent hold in aggregate, not at an individual level. At an individual level, we do observe quits into non-employment as well as EE transitions to newly created jobs in the data. Similarly, unemployed workers may be hired as the replacement instead of being hired for a newly created position. Still, in equilibrium, the number of jobs created must equal the number of jobs destroyed for unemployment to be constant. Likewise, the number of EE transitions must equal the number of replacement hires for employment to be constant.


$$
Job ~~ Creation = Job ~~ Destruction
$$

$$
EE ~~ Transitions = Replacement ~~ Hires
$$

In this simplified view of the labor market, a fall in the share of empty but viable positions that are replaced would show itself in a rise of the share of EE transitions per replacement hire. In other words, workers still transition and leave viable positions behind but positions are not immediately reposted on the labor market. Clearly, this rise in the share of EE transitions per replacement hires can only be temporary, as the reduction in replacement hiring also reduces the number of positions that employed workers can find. Thus, fewer employed workers find a new job and the ratio returns towards it's long-run average.



# Data and Methodology

## File Naming Convention for LEHD Data

The LEHD provides various data sets for the US based on Census data. While the state-level data also contains local and state civil servants, the national aggregates are for private firms only.
Of these private firms, the LEHD data covers about 95% of employees, given that the data is based on unemployment insurance records.
The data is available at the quarterly frequency and not seasonally adjusted except when downloaded through their proprietary acces portal.


<details>
<summary> **LEHD Data Naming Convention** (Click to Expand)</summary>

| **Component** | **Code** | **Description** |
|--------------|---------|----------------|
| **GEOHI (Geography Identifier)** | `all` | All available states |
| | `us` | National data (50 states + DC) |
| | `metro` | CBSA-level collection (metropolitan areas) |
| | `[st]` | Two-letter state postal code (e.g., `ca` for California) |
| | `[NNNNN]` | CBSA-derived code for metro areas |
| **DEMO (Demographic Breakdown)** | `d` | No demographic detail |
| | `rh` | Race by Ethnicity |
| | `sa` | Sex by Age |
| | `se` | Sex by Education |
| | `sarhe` | Combined `sa`, `rh`, and `se` |
| **FAS (Firm Age & Size Breakdown)** | `f` | No firm size or age breakdown |
| | `fa` | Firm age tabulations |
| | `fs` | Firm size tabulations |
| **GEOCAT (Geographic Category)** | `gb` | Metropolitan (complete) |
| | `gc` | Counties |
| | `gm` | Metropolitan/Micropolitan (state parts) |
| | `gn` | National (50 States + DC) |
| | `gs` | States |
| | `gw` | Workforce Investment Areas |
| **INDCAT (Industry Classification)** | `n` | All industries |
| | `ns` | NAICS sectors |
| | `n3` | NAICS subsectors |
| | `n4` | NAICS industry groups |
| **OWNCAT (Ownership Classification)** | `of` | Federal Government |
| | `op` | All Private |
| | `oslp` | State, Local, and Private ownership |
| **SA (Seasonal Adjustment)** | `s` | Seasonally adjusted |
| | `u` | Not seasonally adjusted |
| **EXT (File Format)** | `csv` | Comma-Separated file |
| | `pdf` | Printable PDF |
| | `xls` | Excel (limited availability) |
| | `xlsx` | Excel (not available for large files) |
*Source: [LEHD CSV Naming Convention](https://lehd.ces.census.gov/data/schema/V4.12.0/lehd_csv_naming.html)*

**Quick Example Breakdown**
- **qwi** → Quarterly Workforce Indicators (QWI) Counts
- **us** → National-level data
- **sa** → Sex by Age
- **f** → No firm size or age breakdown
- **gn** → National (50 states + DC)
- **ns** → NAICS sectors
- **op** → All Private ownership
- **u** → Not seasonally adjusted

</details>


---

```{python}
#| label: obtain_data

## Downloading and extracting the data

import os
import requests
import gzip
import shutil
import pandas as pd
from bs4 import BeautifulSoup
import sys

# Base URL
BASE_URL = "https://lehd.ces.census.gov/data/qwi/latest_release/us/"

# Directory setup
BASE_PATH = r"C:\Users\moritz\Nextcloud\PhD\Projects\uncertainty_labor\data"
DOWNLOAD_DIR = os.path.join(BASE_PATH, "qwi_data")
EXTRACT_DIR = os.path.join(BASE_PATH, "qwi_extracted")
os.makedirs(DOWNLOAD_DIR, exist_ok=True)
os.makedirs(EXTRACT_DIR, exist_ok=True)

# User-defined filter (Set to None for all files, or specify exact match criteria)
FILTER_CRITERIA = "qwi_us_sa_f_gn_ns_op_u.csv.gz"  # Specify the exact filename needed
# This is the file name for the most basic aggregate data.
# Future analysis will require more detailed data which is why I downloaded it all already.

# Fetch webpage content
response = requests.get(BASE_URL)
if response.status_code != 200:
    sys.exit()  # Exit silently on failure

# Parse HTML
soup = BeautifulSoup(response.text, "html.parser")

# Extract .csv.gz file links
file_links = [BASE_URL + a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('.csv.gz')]

# Apply exact filename filtering
if FILTER_CRITERIA:
    file_links = [link for link in file_links if FILTER_CRITERIA in link]

if not file_links:
    sys.exit()  # Exit silently if no files are found

# Suppress all printing by redirecting stdout
original_stdout = sys.stdout
sys.stdout = open(os.devnull, 'w')

# gave some issues about printing the chunk size all the time.
try:
    for file_url in file_links:
        file_name = os.path.join(DOWNLOAD_DIR, os.path.basename(file_url))

        # Download file (silent)
        with requests.get(file_url, stream=True) as r:
            with open(file_name, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)

        # Extract file (silent)
        extracted_file_name = os.path.join(EXTRACT_DIR, os.path.basename(file_name).replace(".gz", ""))
        with gzip.open(file_name, 'rb') as f_in, open(extracted_file_name, 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)

        # Read CSV (silent)
        df = pd.read_csv(extracted_file_name)

finally:
    # Restore original stdout
    sys.stdout = original_stdout

print("Data downloaded & extracted successfully.")

# Load dataset into a DataFrame for further analysis
def load_qwi_data():
    data_path = os.path.join(EXTRACT_DIR, FILTER_CRITERIA.replace(".gz", ""))
    if os.path.exists(data_path):
        return pd.read_csv(data_path)  # No print statements
    else:
        return None  # Silent failure


```

---
Now let's take a quick look at the data to know what we are working with and how to proceed.

```{python}
#| label: select_data

## Work with the data

# Take a look at all the different variables
df_qwi = load_qwi_data()
if df_qwi is not None:
    print("Column Names (formatted):")
    import textwrap
column_list = " | ".join(df_qwi.columns)
print(textwrap.fill(column_list, width=100))


# Print unique values for specific columns
columns_to_check = ["seasonadj", "geo_level", "ind_level", "industry", "ownercode", "sex", "agegrp",
                    "race", "ethnicity", "education", "firmage", "firmsize"]  # Adjust column names as needed

for col in columns_to_check:
    if col in df_qwi.columns:
        unique_values = ", ".join(map(str, sorted(df_qwi[col].dropna().unique())))
        print(f"{col}: {unique_values}")
    else:
        print(f"Warning: Column '{col}' not found in DataFrame.")

```

Now that we can see the data and know which variables have various cateogries, we can proceed by extracting the time series that we are most interested in.

The variables typically contained in the QWI data follow in a table below:


<details>
<summary> **Variables Table** (Click to Expand)</summary>

| Indicator Variable | Alternate Name | Status Flag | Indicator Name | Description | Units | Concept | Base |
|-------------------|---------------|-------------|---------------|-------------|-------|---------|------|
| Emp | B | sEmp | Beginning-of-Quarter Employment | Estimate of the total number of jobs on the first day of the reference quarter | Count | Employment | 1 |
| EmpEnd | E | sEmpEnd | End-of-Quarter Employment | Estimate of the number of jobs on the last day of the quarter | Count | Employment | 1 |
| EmpS | F | sEmpS | Full-Quarter Employment (Stable) | Estimate of stable jobs - the number of jobs that are held on both the first and last day of the quarter with the same employer | Count | Employment | 1 |
| EmpTotal | M | sEmpTotal | Employment - Reference Quarter | Estimated count of people employed in a firm at any time during the quarter | Count | Employment | 1 |
| EmpSpv | Fpv | sEmpSpv | Full-Quarter Employment in the Previous Quarter | Estimate of stable jobs in the quarter before the reference quarter | Count | Employment | 1 |
| HirA | A | sHirA | Hires (All Accessions) | Estimated number of workers who started a new job in the specified quarter | Count | Hire | 1 |
| HirN | H | sHirN | New Hires | Estimated number of workers who started a new job excluding recall hires | Count | Hire | 1 |
| HirR | R | sHirR | Recall Hires | Estimated number of workers who returned to the same employer where they had worked within the previous year | Count | Hire | 1 |
| Sep | S | sSep | Separations (All) | Estimated number of workers whose job with a given employer ended in the specified quarter | Count | Separation | 1 |
| HirAEnd | CA | sHirAEnd | End-of-Quarter Hires | Estimated number of workers who started a new job in the specified quarter, which continued into next quarter | Count | Hire | 1 |
| SepBeg | CS | sSepBeg | Beginning-of-Quarter Separations | Estimated number of workers whose job in the previous quarter continued and ended in the given quarter | Count | Separation | 1 |
| HirAEndRepl | EI | sHirAEndRepl | Replacement Hires | Hires into continuous quarter employment in excess of job creation | Count | Hire | 1 |
| HirAEndR | CAR | sHirAEndR | End-of-Quarter Hiring Rate | Hires as a percent of average employment | Rate | Hire | (Emp + EmpEnd)/2 |
| SepBegR | CSR | sSepBegR | Beginning-of-Quarter Separation Rate | Separations as a percent of average employment | Rate | Separation | (Emp + EmpEnd)/2 |
| HirAEndReplR | EIR | sHirAEndReplR | Replacement Hiring Rate | Replacement hires as a percent of the average of beginning- and end-of-quarter employment | Rate | Hire | (Emp + EmpEnd)/2 |
| HirAS | FA | sHirAS | Hires (All Hires into Full-Quarter Employment) | Estimated number of workers that started a job that lasted at least one full quarter with a given employer | Count | Hire | 1 |
| HirNS | FH | sHirNS | New Hires (New Hires into Full-Quarter Employment) | Estimated number of workers who started a job that they had not held within the past year and the job turned into a job that lasted at least a full quarter with a given employer | Count | Hire | 1 |
| SepS | FS | sSepS | Separations (Flows out of Full-Quarter Employment) | Estimated number of workers who had a job for at least a full quarter and then the job ended | Count | Separation | 1 |
| SepSnx | FSnx | sSepSnx | Separations in the Next Quarter (Flows out of Full-Quarter Employment) | Estimated number of workers in the next quarter who had a job for at least a full quarter and then the job ended | Count | Separation | 1 |
| TurnOvrS | FT | sTurnOvrS | Turnover (Stable) | The rate at which stable jobs begin and end | Rate | Turnover | 2*EmpS |
| FrmJbGn | JC | sFrmJbGn | Firm Job Gains (Job Creation) | Estimated number of jobs gained at firms throughout the quarter | Count | Job Flows | 1 |
| FrmJbLs | JD | sFrmJbLs | Firm Job Loss (Job Destruction) | Estimated number of jobs lost at firms throughout the quarter | Count | Job Flows | 1 |
| FrmJbC | JF | sFrmJbC | Firm Job Change (Net Change) | Difference between firm job gain and firm job loss | Count | Job Flows | 1 |
| FrmJbGnS | FJC | sFrmJbGnS | Firm Job Gains (Stable) | Estimated number of full-quarter jobs gained at firms | Count | Job Flows | 1 |
| FrmJbLsS | FJD | sFrmJbLsS | Firm Job Loss (Stable) | Estimated number of full-quarter jobs lost at firms | Count | Job Flows | 1 |
| FrmJbCS | FJF | sFrmJbCS | Firm Job Change (Stable; Net Change) | Net growth in jobs that last a full quarter | Count | Job Flows | 1 |
| EarnS | ZW3 | sEarnS | Average Monthly Earnings (Full-Quarter Employment) | Average monthly earnings of employees with stable jobs | Dollars | Earnings | EmpS |
| EarnBeg | ZW2B | sEarnBeg | Average Monthly Earnings (Beginning-of-Quarter Employment) | Average monthly earnings of employees who worked on the first day of the reference quarter | Dollars | Earnings | Emp |
| EarnHirAS | ZWFA | sEarnHirAS | Average Monthly Earnings (All Hires into Full-Quarter Employment) | Average monthly earnings for workers who started a job that turned into a job lasting a full quarter | Dollars | Earnings | HirAS |
| EarnHirNS | ZWFH | sEarnHirNS | Average Monthly Earnings (New Hires into Full-Quarter Employment) | Average monthly earnings of newly stable employees | Dollars | Earnings | HirNS |
| EarnSepS | ZWFS | sEarnSepS | Average Monthly Earnings (Flows out of Full-Quarter Employment) | Average monthly earnings of separations from full-quarter status at an establishment | Dollars | Earnings | SepSnx |
| Payroll | W1 | sPayroll | Total Quarterly Payroll | Total quarterly payroll for all jobs | Dollars | Earnings | 1 |

*Source: [LEHD Public Use Schema](https://lehd.ces.census.gov/data/schema/V4.12.0/lehd_public_use_schema.html)*

</details>

The categorical variables show us additional levels of detail that we can ge, beyond the basic aggregates.


<details>
<summary> **Categorical Variables Table** (Click to Expand)</summary>

**5.1. Agegrp**

| **agegrp** | **Label** |
|-----------|--------------------------------|
| A00       | All Ages (14-99)               |
| A01       | 14-18                          |
| A02       | 19-21                          |
| A03       | 22-24                          |
| A04       | 25-34                          |
| A05       | 35-44                          |
| A06       | 45-54                          |
| A07       | 55-64                          |
| A08       | 65-99                          |

**5.2. Education**

| **education** | **Label** |
|--------------|--------------------------------------------------------|
| E0          | All Education Categories                              |
| E1          | Less than high school                                 |
| E2          | High school or equivalent, no college                 |
| E3          | Some college or Associate degree                      |
| E4          | Bachelor’s degree or advanced degree                  |
| E5          | Educational attainment not available (workers < 24)    |

**5.3. Ethnicity**

| **ethnicity** | **Label** |
|-------------|---------------------------|
| A0          | All Ethnicities            |
| A1          | Not Hispanic or Latino     |
| A2          | Hispanic or Latino         |

**5.4. Firmage**

| **firmage** | **Label** |
|-----------|------------------------------|
| 0         | All Firm Ages                |
| 1         | 0-1 Years                    |
| 2         | 2-3 Years                    |
| 3         | 4-5 Years                    |
| 4         | 6-10 Years                   |
| 5         | 11+ Years                    |
| N         | Firm Age Not Available       |

**5.5. Firmsize**

| **firmsize** | **Label** |
|------------|------------------------------|
| 0         | All Firm Sizes                |
| 1         | 0-19 Employees                |
| 2         | 20-49 Employees               |
| 3         | 50-249 Employees              |
| 4         | 250-499 Employees             |
| 5         | 500+ Employees                |
| N         | Firm Size Not Available       |

**5.6. Ownercode**

| **ownercode** | **Label** |
|-------------|------------------------------------------|
| A00        | State and local government + private    |
| A01        | Federal government                      |
| A05        | All Private                             |

**5.7. Periodicity**

| **periodicity** | **Label** |
|--------------|-----------------|
| A          | Annual data      |
| Q          | Quarterly data   |

**5.8. Quarter**

| **quarter** | **Label** |
|---------|------------------------------------|
| 1       | 1st Quarter (Jan-Mar)            |
| 2       | 2nd Quarter (Apr-Jun)            |
| 3       | 3rd Quarter (Jul-Sep)            |
| 4       | 4th Quarter (Oct-Dec)            |

**5.9. Race**

| **race** | **Label** |
|--------|---------------------------------------------|
| A0     | All Races                                  |
| A1     | White Alone                                |
| A2     | Black or African American Alone           |
| A3     | American Indian or Alaska Native Alone    |
| A4     | Asian Alone                               |
| A5     | Native Hawaiian or Other Pacific Islander |
| A6     | Some Other Race Alone (Not Used)         |
| A7     | Two or More Race Groups                   |

**5.10. Seasonadj**

| **seasonadj** | **Label** |
|-----------|-----------------------|
| S         | Seasonally adjusted   |
| U         | Not seasonally adjusted |

**5.11. Sex**

| **sex** | **Label** |
|------|--------------|
| 0    | All Sexes   |
| 1    | Male       |
| 2    | Female     |


**5.12.1. Industry Levels**

| **ind_level** | **Label** |
|-------------|----------------------|
| A         | All Industries       |
| S         | NAICS Sectors        |
| 3         | NAICS Subsectors     |
| 4         | NAICS Industry Groups |

**5.12.2. Industry**

| **industry** | **Label** | **ind_level** |
|------------|-------------------------------------------------|-------------|
| 00         | All NAICS Sectors                               | A           |
| 000        | All NAICS Subsectors                           | A           |
| 0000       | All NAICS Industry Groups                     | A           |
| 11         | Agriculture, Forestry, Fishing and Hunting    | S           |
| 111        | Crop Production                               | 3           |
| 1111       | Oilseed and Grain Farming                    | 4           |
| 1112       | Vegetable and Melon Farming                  | 4           |
| ...        | ...                                           | ...         |
| 2383       | Building Finishing Contractors               | 4           |
| 2389       | Other Specialty Trade Contractors            | 4           |
| 31-33      | Manufacturing                                | S           |
| 311        | Food Manufacturing                          | 3           |
| 3111       | Animal Food Manufacturing                   | 4           |
| 3112       | Grain and Oilseed Milling                   | 4           |
| 3113       | Sugar and Confectionery Product Manufacturing | 4           |
| ...        | ...                                           | ...         |


**5.13. Degree Level**

| **degree_level** | **Label** |
|--------------|----------------------------------|
| 00         | All Degree Levels                |
| 01         | Certificate < 1 year             |
| 02         | Certificate 1-2 years            |
| 03         | Associate's Degree               |
| 04         | Certificate 2-4 years            |
| 05         | Baccalaureate                     |
| 06         | Post-Baccalaureate Certificate   |
| 07         | Master's Degree                  |
| 08         | Post-Master's Certificate        |
| 17         | Doctoral - Research/Scholarship  |
| 18         | Doctoral - Professional Practice |

*Source: [LEHD Public Use Schema](https://lehd.ces.census.gov/data/schema/V4.12.0/lehd_public_use_schema.html)*

<details>


```{python}
#| label: View_the_data


## Create date variable
df_qwi_filtered = df_qwi[
    (df_qwi["sex"] == 0) &
    (df_qwi["agegrp"] == "A00") &
    (df_qwi["industry"] == "00") &
    (df_qwi["ind_level"] == "A")
].copy()  # Copy to avoid modifying the original DataFrame

df_qwi_filtered["date"] = pd.PeriodIndex(
    df_qwi_filtered["year"].astype(str) + "Q" + df_qwi_filtered["quarter"].astype(str),
    freq="Q"
).to_timestamp()

# Drop unnecessary columns
df_qwi_filtered.drop(columns=["periodicity", "seasonadj", "geo_level", "ind_level", "industry",
                              "ownercode", "sex", "agegrp", "race", "ethnicity", "education",
                              "firmage", "firmsize", "year", "quarter", "geography"], inplace=True)

# Ensure "date" is the first column
df_qwi_filtered = df_qwi_filtered[["date"] + [col for col in df_qwi_filtered.columns if col != "date"]]


# Export to deseasonalize in R
df_qwi_filtered.to_csv("temp_df.csv", index=False)

print("Data filtered and ready for deseasonalization.")

```

It turns out that we need to use R (together with python) to use the usual seasonal adjustment with X13-ARIMA.

```{python}
#| label: seasonal_adjustment

import subprocess

# Run the R script
subprocess.run(["Rscript", "sheet_seas_adjust.r"], check=True)

# Clean up by deleting the temp file
os.remove("temp_df.csv")

print("Data deseasonalized successfully.")

df_qwi_filtered = pd.read_csv("qwi_data_seasadj.csv")
```

```{python}
#| label: load_additional_data
#| echo: false

# We still need some data from FRED
from fredapi import Fred
import pandas as pd

API_KEY = open(r"C:\Users\moritz\Nextcloud\PhD\Confidential\fred_api_key.txt").read().strip()
fred = Fred(api_key=API_KEY)

# Chose both nonfarm and totalprivate data
fred_monthly_dict = {
    "ts_jopen_nfarm_lvl_m": "JTSJOL", "ts_jopen_nfarm_rate_m": "JTSJOR",
    "ts_jopen_tpriv_lvl_m": "JTS1000JOL", "ts_jopen_tpriv_rate_m": "JTS1000JOR",

    "ts_quit_nfarm_lvl_m": "JTSQUL", "ts_quit_nfarm_rate_m": "JTSQUR",
    "ts_quit_tpriv_lvl_m": "JTS1000QUL", "ts_quit_tpriv_rate_m": "JTS1000QUR",

    "ts_hire_nfarm_lvl_m": "JTSHIL", "ts_hire_nfarm_rate_m": "JTSHIR",
    "ts_hire_tpriv_lvl_m": "JTS1000HIL", "ts_hire_tpriv_rate_m": "JTS1000HIR",

    "ts_layoff_nfarm_lvl_m": "JTSLDL", "ts_layoff_nfarm_rate_m": "JTSLDR",
    "ts_layoff_tpriv_lvl_m": "JTS1000LDL", "ts_layoff_tpriv_rate_m": "JTS1000LDR",

    "ts_osep_nfarm_lvl_m": "JTSOSL", "ts_osep_nfarm_rate_m": "JTSOSR",
    "ts_osep_tpriv_lvl_m": "JTS1000OSL", "ts_osep_tpriv_rate_m": "JTS1000OSR",

    "ts_tsep_nfarm_lvl_m": "JTSTSL", "ts_tsep_nfarm_rate_m": "JTSTSR",
    "ts_tsep_tpriv_lvl_m": "JTS1000TSL", "ts_tsep_tpriv_rate_m": "JTS1000TSR",

    "ts_jln_uncertainty_m": "JLNUM3M",

    # Employment data
    "ts_emp_lvl_CPS_m": "CE16OV",  # CPS employment level
    "ts_emp_nfarm_CES_m": "PAYEMS",  # CES nonfarm payroll employment
    "ts_emp_priv_CES_m": "USPRIV",  # CES private employment

    # EE probability data
    "ts_ee_prob_m": "FMPSA"
}

# Define date range
start_date = "1990-01-01"
end_date = "2025-01-01"

# It's a pain to have all in the same df because of their different length availability
for var_name, series_id in fred_monthly_dict.items():
    df = fred.get_series(series_id, start_date, end_date).reset_index()
    df.columns = ["Date", "Value"]
    globals()[var_name] = df

# Define aggregation methods
taggr_methods = {
    "sum": ["ts_jopen_nfarm_lvl_m", "ts_jopen_tpriv_lvl_m", "ts_quit_nfarm_lvl_m", "ts_quit_tpriv_lvl_m",
             "ts_hire_nfarm_lvl_m", "ts_hire_tpriv_lvl_m", "ts_layoff_nfarm_lvl_m", "ts_layoff_tpriv_lvl_m",
             "ts_osep_nfarm_lvl_m", "ts_osep_tpriv_lvl_m", "ts_tsep_nfarm_lvl_m", "ts_tsep_tpriv_lvl_m"],
    "mean": ["ts_jopen_nfarm_rate_m", "ts_jopen_tpriv_rate_m", "ts_quit_nfarm_rate_m", "ts_quit_tpriv_rate_m",
              "ts_hire_nfarm_rate_m", "ts_hire_tpriv_rate_m", "ts_layoff_nfarm_rate_m", "ts_layoff_tpriv_rate_m",
              "ts_osep_nfarm_rate_m", "ts_osep_tpriv_rate_m", "ts_tsep_nfarm_rate_m", "ts_tsep_tpriv_rate_m",
              "ts_jln_uncertainty_m", "ts_emp_lvl_CPS_m", "ts_emp_nfarm_CES_m", "ts_emp_priv_CES_m",
              "ts_ee_prob_m"]
}

# Aggregate to quarterly data
for method, series_list in taggr_methods.items():
    for series in series_list:
        df = globals()[series].copy()
        df["Date"] = pd.to_datetime(df["Date"])
        df.set_index("Date", inplace=True)
        if method == "sum":
            df_q = df.resample("QE").sum().reset_index()
        else:  # mean
            df_q = df.resample("QE").mean().reset_index()
        globals()[series.replace("_m", "_q")] = df_q



```


# Replacement Hiring in the Data


```{python}
#| label: figure_templates
#| echo: false

import os
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime
import numpy as np


# Load the adjusted data
df_qwi_filtered = pd.read_csv("qwi_data_seasadj.csv")

# Define color palettes
palette = {
    "palette_1": "#003f5c",
    "palette_2": "#ffa600",
    "palette_3": "#ff6361",
    "palette_4": "#2db88b"
}

extended_palette = {
    "palette_1": "#003f5c",
    "palette_2": "#58508d",
    "palette_3": "#bc5090",
    "palette_4": "#ff6361",
    "palette_5": "#ffa600",
    "palette_6": "#2db88b"
}

# Single Time Series
def fun_plot_single_ts(df, title="Time Series Plot", xlabel="Date", ylabel="Value", color=palette["palette_1"], recession_shading=True, recessions=None, scale_factor=1):
    df.iloc[:, 0] = pd.to_datetime(df.iloc[:, 0])

    if recessions is None:
        recessions = [("2001-03-01", "2001-11-01"), ("2007-12-01", "2009-06-01"), ("2020-02-01", "2020-04-01")]

    recession_periods = [(datetime.strptime(start, "%Y-%m-%d"), datetime.strptime(end, "%Y-%m-%d")) for start, end in recessions]
    df.iloc[:, 1] /= scale_factor

    fig, ax = plt.subplots(figsize=(12, 6))
    ax.plot(df.iloc[:, 0], df.iloc[:, 1], color=color, linewidth=2, label='_nolegend_')

    if recession_shading:
        for start, end in recession_periods:
            ax.axvspan(start, end, color="grey", alpha=0.3)

    ax.set_xlabel(xlabel, fontsize=14, fontweight="bold")
    ax.set_ylabel(ylabel, fontsize=14, fontweight="bold")
    ax.set_title(title, fontsize=16, fontweight="bold")

    ax.xaxis.set_major_locator(mdates.YearLocator(base=5))
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
    ax.tick_params(axis='x', rotation=45, labelsize=12)
    ax.tick_params(axis='y', labelsize=12)
    ax.grid(False)
    plt.tight_layout()
    plt.show()

# Three Time Series
def fun_plot_three_ts(df1, df2, df3, title="Time Series Plot", xlabel="Date", ylabel="Value", color1=palette["palette_1"], color2=palette["palette_2"], color3=palette["palette_3"], line_type2="solid", line_type3="dashed", recession_shading=True, recessions=None, legend1="Series 1", legend2="Series 2", legend3="Series 3", scale_factor=1):
    df1.iloc[:, 0] = pd.to_datetime(df1.iloc[:, 0])
    df2.iloc[:, 0] = pd.to_datetime(df2.iloc[:, 0])
    df3.iloc[:, 0] = pd.to_datetime(df3.iloc[:, 0])

    df_combined = pd.merge(pd.merge(df1, df2, on=df1.columns[0], how='outer'), df3, on=df1.columns[0], how='outer')
    df_combined.iloc[:, 1:] /= scale_factor

    if recessions is None:
        recessions = [("2001-03-01", "2001-11-01"), ("2007-12-01", "2009-06-01"), ("2020-02-01", "2020-04-01")]

    recession_periods = [(datetime.strptime(start, "%Y-%m-%d"), datetime.strptime(end, "%Y-%m-%d")) for start, end in recessions]

    fig, ax = plt.subplots(figsize=(12, 6))
    ax.plot(df_combined.iloc[:, 0], df_combined.iloc[:, 1], color=color1, linewidth=2, label=legend1)
    ax.plot(df_combined.iloc[:, 0], df_combined.iloc[:, 2], color=color2, linewidth=2, linestyle=line_type2, label=legend2)
    ax.plot(df_combined.iloc[:, 0], df_combined.iloc[:, 3], color=color3, linewidth=2, linestyle=line_type3, label=legend3)

    if recession_shading:
        for start, end in recession_periods:
            ax.axvspan(start, end, color="grey", alpha=0.3)

    ax.set_xlabel(xlabel, fontsize=14, fontweight="bold")
    ax.set_ylabel(ylabel, fontsize=14, fontweight="bold")
    ax.set_title(title, fontsize=16, fontweight="bold")

    ax.xaxis.set_major_locator(mdates.YearLocator(base=5))
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))
    ax.tick_params(axis='x', rotation=45, labelsize=12)
    ax.tick_params(axis='y', labelsize=12)
    ax.grid(False)
    ax.legend()
    plt.tight_layout()
    plt.show()



def fun_plot_three_bars(df1, df2, df3, date_col, value_col1, value_col2, value_col3, line_col=None, line_color='#FFA600', line_legend='Trend Line', title="Labor Market Indicators Over Time", xlabel="Date", ylabel="Levels (in millions)", color1="#003f5c", color2="#58508d", color3="#bc5090", legend1="Replacement", legend2="Hires", legend3="All Hires", scale_factor=1000000):
    # Convert date columns to datetime format
    df1 = df1.copy()
    df2 = df2.copy()
    df3 = df3.copy()
    df1[date_col] = pd.to_datetime(df1[date_col])
    df2[date_col] = pd.to_datetime(df2[date_col])
    df3[date_col] = pd.to_datetime(df3[date_col])

    # Apply scaling
    df1[value_col1] /= scale_factor
    df2[value_col2] /= scale_factor
    df3[value_col3] /= scale_factor

    # Merge dataframes on date column
    df = df1.merge(df2, on=date_col, how='outer').merge(df3, on=date_col, how='outer')
    df = df.sort_values(by=date_col)

    # Set x positions with uniform spacing
    x_pos = np.arange(len(df))
    bar_width = 1.0  # Ensure bars are tightly packed with no white space

    # Create stacked bar chart
    fig, ax = plt.subplots(figsize=(12, 6))
    y1 = df[value_col1]
    y2 = df[value_col2]
    y3 = df[value_col3]

    ax.bar(x_pos, y1, color=color1, label=legend1, width=bar_width, align='edge', edgecolor='none')
    ax.bar(x_pos, y2, bottom=y1, color=color2, label=legend2, width=bar_width, align='edge', edgecolor='none')
    ax.bar(x_pos, y3, bottom=y1 + y2, color=color3, label=legend3, width=bar_width, align='edge', edgecolor='none')

    # Add optional line plot
    if line_col:
        ax.plot(x_pos, df[line_col], color=line_color, linewidth=2, linestyle="solid", label=line_legend)

    # Set x-axis ticks correctly to show every year
    ax.set_xticks(x_pos[::4])  # Assuming quarterly data, show every 4th entry (annually)
    ax.set_xticklabels(df[date_col].dt.strftime('%Y')[::4], rotation=45, ha='right')

    # Labels and title
    ax.set_xlabel(xlabel, fontsize=14, fontweight="bold")
    ax.set_ylabel(ylabel, fontsize=14, fontweight="bold")
    ax.set_title(title, fontsize=16, fontweight="bold")
    ax.legend()

    # Show the plot
    plt.show()


def fun_plot_two_bars(df1, df2, df_line=None, date_col=None, value_col1=None, value_col2=None, line_col=None, line_color='#ffa600', line_legend='Trend Line', title="Labor Market Indicators Over Time", xlabel="Date", ylabel="Levels (in millions)", color1="#003f5c", color2="#58508d", legend1="Replacement", legend2="Hires", scale_factor=1000000):

    # Convert date columns to datetime format
    df1 = df1.copy()
    df2 = df2.copy()
    df1[date_col] = pd.to_datetime(df1[date_col])
    if df_line is not None:
        df_line = df_line.copy()
        df_line[date_col] = pd.to_datetime(df_line[date_col])
    df2[date_col] = pd.to_datetime(df2[date_col])

    # Apply scaling
    df1[value_col1] /= scale_factor
    df2[value_col2] /= scale_factor
    if df_line is not None and line_col:
        df_line[line_col] /= scale_factor

    # Merge dataframes on date column
    df = df1.merge(df2, on=date_col, how='outer')
    if df_line is not None:
        df = df.merge(df_line, on=date_col, how='outer')
    df = df.sort_values(by=date_col)

    # Set x positions with uniform spacing
    x_pos = np.arange(len(df))
    bar_width = 1.0  # Ensure bars are tightly packed with no white space

    # Create stacked bar chart
    fig, ax = plt.subplots(figsize=(12, 6))
    y1 = df[value_col1]
    y2 = df[value_col2]

    ax.bar(x_pos, y1, color=color1, label=legend1, width=bar_width, align='edge', edgecolor='none')
    ax.bar(x_pos, y2, bottom=y1, color=color2, label=legend2, width=bar_width, align='edge', edgecolor='none')

    # Add optional line plot
    if df_line is not None and line_col:
        ax.plot(x_pos, df[line_col], color=line_color, linewidth=3, linestyle="solid", label=line_legend)

    # Set x-axis ticks correctly to show every year
    ax.set_xticks(x_pos[::4])  # Assuming quarterly data, show every 4th entry (annually)
    ax.set_xticklabels(df[date_col].dt.strftime('%Y')[::4], rotation=45, ha='right')

    # Labels and title
    ax.set_xlabel(xlabel, fontsize=14, fontweight="bold")
    ax.set_ylabel(ylabel, fontsize=14, fontweight="bold")
    ax.set_title(title, fontsize=16, fontweight="bold")
    ax.legend()

    # Show the plot
    plt.show()


```

First, let us take a look at replacement hiring in the data. These two figures give us a glance both at the volatility and cyclicality of replacement hiring as well as its role in total hires.


```{python}
#| label: plot_series
#| fig-cap: "Charts"
#| fig-subcap:
#|   - "We can immediately see that replacement hiring is very volatile and strongly decreases in recessions."
#|   - "The decomposition of hires into replacement hires and job creation holds in the data. Moreover, the importance is for total hires becomes clear."
#| layout-ncol: 2


## To simplify the plotting, let's extract some data from the QWI df
df_qwi_ReplHires = df_qwi_filtered[["date", "HirAEndRepl"]].copy()
df_qwi_Hires = df_qwi_filtered[["date", "HirAEnd"]].copy()
df_qwi_JobCreation = df_qwi_filtered[["date", "FrmJbGn"]].copy()
df_qwi_JobDestruction = df_qwi_filtered[["date", "FrmJbLs"]].copy()

## due to NAs  and outliers, we shorten the time window for all series:

start_date = "1993-07-01"
end_date = "2023-01-01"

df_qwi_ReplHires = df_qwi_ReplHires[(df_qwi_ReplHires["date"] >= start_date) & (df_qwi_ReplHires["date"] <= end_date)]
df_qwi_Hires = df_qwi_Hires[(df_qwi_Hires["date"] >= start_date) & (df_qwi_Hires["date"] <= end_date)]
df_qwi_JobCreation = df_qwi_JobCreation[(df_qwi_JobCreation["date"] >= start_date) & (df_qwi_JobCreation["date"] <= end_date)]
df_qwi_JobDestruction = df_qwi_JobDestruction[(df_qwi_JobDestruction["date"] >= start_date) & (df_qwi_JobDestruction["date"] <= end_date)]



## Plot: Replacement hiring per hire & its shortfalls

# Construct share of replacement hires in total hires
df_qwi_ReplShare = df_qwi_ReplHires.copy()
df_qwi_ReplShare["ReplShare"] = df_qwi_ReplHires["HirAEndRepl"] / df_qwi_Hires["HirAEnd"]

fun_plot_single_ts(
    df=df_qwi_ReplShare,
    title="Replacement Hires as Share of Total Hires",
    xlabel="Date",
    ylabel="Share of Replacement Hires (in millions)",
    recession_shading=True,
    scale_factor=1000000
)

fun_plot_two_bars(
    df_qwi_ReplHires, df_qwi_JobCreation, df_line=df_qwi_Hires,
    date_col="date",
    value_col1="HirAEndRepl", value_col2="FrmJbGn",
    line_col="HirAEnd", line_legend="Replacement Hires"
)

```


Here comes the outline for the analysis:

Task before:

- Write up the model part with the equations and how things look in steady state


1. Show a decomposition of hiring into replacement hiring and job creation
2. Show a decomposition of replacement hires into job-to-job transitions to show that the relationship should hold.

- Here however this may undermine my argument / I will have to credibly argue that the data is systematially missing these kinds of transitions because it is just quarterly
- At the same time, these series are very similar
- I should think about this more => well actually the hires that they show there are from a different data set and only concern main jobs. Moreover, there is this weirdness about the employment series.

3. Construct the two possible ways to get at the number of replaceable positions. *a)* like Alek's WP and *b)* like me own
4. Compare these two versions and then go over to the models
5.
